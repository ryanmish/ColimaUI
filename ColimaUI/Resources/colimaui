#!/usr/bin/env bash
set -euo pipefail

PATH="/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/local/sbin:$PATH"

SCRIPT_NAME="colimaui"
CLI_VERSION="1.1.16"
DNS_PORT="53535"
MANAGED_DNSMASQ_CONFIG="colimaui.conf"
MKCERT_CAROOT="${HOME}/Library/Application Support/ColimaUI/mkcert-v2"
CERT_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/certs"
DYNAMIC_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/dynamic"
LOCK_DIR=""

log() {
  printf '%s\n' "$*"
}

warn() {
  printf 'WARN: %s\n' "$*" >&2
}

err() {
  printf 'ERROR: %s\n' "$*" >&2
}

die() {
  err "$*"
  exit 1
}

usage() {
  cat <<'EOF'
ColimaUI CLI

Usage:
  colimaui --version
  colimaui domains setup
  colimaui domains trust
  colimaui domains check
  colimaui domains sync
  colimaui domains urls [--json]
  colimaui domains unsetup [--purge-packages]

Notes:
  - Domain suffix is fixed to "dev.local".
  - setup/unsetup may request macOS admin credentials for resolver and DNS changes.
  - trust may request macOS admin credentials for certificate trust changes.
EOF
}

normalize_suffix() {
  printf '%s' "${1:-}" \
    | tr '[:upper:]' '[:lower:]' \
    | sed -E 's/^[.]+//; s/[[:space:]]+//g'
}

brew_prefix() {
  if command -v brew >/dev/null 2>&1; then
    brew --prefix
    return
  fi
  if [[ -d /opt/homebrew ]]; then
    printf '%s' "/opt/homebrew"
  else
    printf '%s' "/usr/local"
  fi
}

shell_quote() {
  local value="${1:-}"
  printf "'%s'" "${value//\'/\'\\\'\'}"
}

system_curl() {
  local curl_bin="/usr/bin/curl"
  if [[ ! -x "$curl_bin" ]]; then
    curl_bin="$(command -v curl || true)"
  fi
  [[ -n "$curl_bin" ]] || return 127
  "$curl_bin" "$@"
}

run_admin_command() {
  local script="${1:-}"
  local prompt="${2:-ColimaUI needs administrator permission to configure local domains.}"
  local encoded=""

  encoded="$(printf '%s' "$script" | /usr/bin/base64 | tr -d '\n')"
  [[ -n "$encoded" ]] || die "Failed to prepare admin command."

  /usr/bin/osascript >/dev/null <<EOF
set payload to "$encoded"
do shell script "echo " & quoted form of payload & " | /usr/bin/base64 -D | /bin/zsh -l" with prompt "$prompt" with administrator privileges
EOF
}

acquire_operation_lock() {
  local lock_path="${TMPDIR:-/tmp}/colimaui-domains.lock"
  local attempts=0

  while ! mkdir "$lock_path" >/dev/null 2>&1; do
    attempts=$((attempts + 1))
    if (( attempts >= 80 )); then
      die "Another local-domain operation is running. Try again in a few seconds."
    fi
    sleep 0.25
  done

  LOCK_DIR="$lock_path"
}

release_operation_lock() {
  if [[ -n "${LOCK_DIR:-}" ]]; then
    rmdir "$LOCK_DIR" >/dev/null 2>&1 || true
    LOCK_DIR=""
  fi
}

with_operation_lock() {
  acquire_operation_lock
  trap 'release_operation_lock' EXIT INT TERM
  "$@"
  local exit_code=$?
  trap - EXIT INT TERM
  release_operation_lock
  return $exit_code
}

dnsmasq_running() {
  lsof -nP -iTCP:"${DNS_PORT}" -iUDP:"${DNS_PORT}" 2>/dev/null | grep -qi 'dnsmasq'
}

docker_reachable() {
  colima status >/dev/null 2>&1 && docker info >/dev/null 2>&1
}

label_value() {
  local labels="$1"
  local key="$2"
  printf '%s' "${labels:-}" | awk -F',' -v k="${key}=" '
    {
      for (i = 1; i <= NF; i++) {
        if (index($i, k) == 1) {
          print substr($i, length(k) + 1)
          exit
        }
      }
    }
  '
}

normalize_domain_label() {
  local v="$1"
  v="$(printf '%s' "$v" | tr '[:upper:]_' '[:lower:]-' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//')"
  printf '%s' "$v"
}

normalize_full_domain() {
  local v="$1"
  local wildcard="0"
  v="$(printf '%s' "$v" | tr '[:upper:]' '[:lower:]')"
  v="${v#http://}"
  v="${v#https://}"
  v="${v%%/*}"
  v="$(printf '%s' "$v" | sed -E 's/^[.]+//; s/[.]+$//; s/[[:space:]]+//g')"
  if [[ -z "$v" ]]; then
    return 1
  fi

  if [[ "$v" == "*."* ]]; then
    wildcard="1"
    v="${v#*.}"
  fi

  if [[ "$v" == *"*"* ]]; then
    return 1
  fi

  local out=""
  local part=""
  local sanitized=""
  local first="1"
  IFS='.' read -r -a domain_parts <<< "$v"
  for part in "${domain_parts[@]}"; do
    sanitized="$(normalize_domain_label "$part")"
    if [[ -z "$sanitized" ]]; then
      return 1
    fi
    if [[ "$first" == "1" ]]; then
      out="$sanitized"
      first="0"
    else
      out="${out}.${sanitized}"
    fi
  done

  if [[ "$wildcard" == "1" ]]; then
    printf '*.%s' "$out"
  else
    printf '%s' "$out"
  fi
}

preferred_http_port() {
  local ports="$1"
  local labels="$2"
  local override=""
  local p=""

  override="$(label_value "$labels" "dev.colimaui.http-port" || true)"
  if [[ "$override" =~ ^[0-9]+$ ]] && (( override >= 1 && override <= 65535 )); then
    printf '%s' "$override"
    return 0
  fi

  local candidates=""
  local segment=""
  local rhs=""
  local c=""
  IFS=',' read -r -a port_segments <<< "$ports"
  for segment in "${port_segments[@]}"; do
    segment="$(printf '%s' "$segment" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
    c=""
    if [[ "$segment" == *"->"* ]]; then
      rhs="${segment#*->}"
      c="${rhs%%/*}"
    elif [[ "$segment" != *":"* && "$segment" == */* ]]; then
      c="${segment%%/*}"
    fi
    if [[ "$c" =~ ^[0-9]+$ ]] && (( c >= 1 && c <= 65535 )); then
      if ! printf '%s\n' "$candidates" | grep -Fxq "$c"; then
        candidates="${candidates}${c}"$'\n'
      fi
    fi
  done

  for p in 80 8080 3000 5173 8000 5000 4200 4000 9000 8888 443 7000 1337; do
    if printf '%s' "$candidates" | grep -Fxq "$p"; then
      printf '%s' "$p"
      return 0
    fi
  done

  printf '%s' ""
}

ensure_proxy_container() {
  local dynamic_dir="$1"
  local cert_dir="$2"
  local force_restart="${3:-0}"

  docker_reachable || return 0
  mkdir -p "$dynamic_dir" "$cert_dir"

  if [[ "$force_restart" == "1" ]]; then
    docker rm -f colimaui-proxy >/dev/null 2>&1 || true
  fi

  if ! docker ps --format '{{.Names}}' | grep -Fxq 'colimaui-proxy'; then
    docker rm -f colimaui-proxy >/dev/null 2>&1 || true
    docker run -d --name colimaui-proxy --restart unless-stopped \
      -p 80:80 -p 443:443 \
      -v "$dynamic_dir:/etc/traefik/dynamic" \
      -v "$cert_dir:/etc/traefik/certs:ro" \
      traefik:v2.11 \
      --providers.file.directory=/etc/traefik/dynamic \
      --providers.file.watch=true \
      --api.dashboard=true \
      --entrypoints.web.address=:80 \
      --entrypoints.web.http.redirections.entryPoint.to=websecure \
      --entrypoints.web.http.redirections.entryPoint.scheme=https \
      --entrypoints.websecure.http.tls=true \
      --entrypoints.websecure.address=:443 >/dev/null
  fi
}

attach_proxy_to_networks() {
  docker_reachable || return 0
  docker ps --format '{{.Names}}' | grep -Fxq 'colimaui-proxy' || return 0

  local networks=""
  networks="$(docker ps -q | while read -r id; do
    docker inspect --format '{{range $name, $_ := .NetworkSettings.Networks}}{{$name}} {{end}}' "$id" 2>/dev/null || true
  done | tr ' ' '\n' | sed '/^$/d' | sort -u || true)"

  local network=""
  for network in $networks; do
    [[ "$network" == "host" || "$network" == "none" ]] && continue
    docker network connect "$network" colimaui-proxy >/dev/null 2>&1 || true
  done
}

write_tls_dynamic() {
  local suffix="$1"
  local dynamic_dir="$2"
  mkdir -p "$dynamic_dir"
  cat > "${dynamic_dir}/tls.yml" <<EOF
tls:
  stores:
    default:
      defaultCertificate:
        certFile: /etc/traefik/certs/${suffix}.pem
        keyFile: /etc/traefik/certs/${suffix}-key.pem
EOF
}

proxy_identity_reachable() {
  local suffix="$1"
  local cert_file="$2"
  local expected_fp served_fp

  [[ -f "$cert_file" ]] || return 1

  expected_fp="$(openssl x509 -in "$cert_file" -noout -fingerprint -sha256 2>/dev/null | awk -F= '{print $2}' | tr -d '[:space:]' || true)"
  served_fp="$(echo | openssl s_client -connect "index.${suffix}:443" -servername "index.${suffix}" 2>/dev/null | openssl x509 -noout -fingerprint -sha256 2>/dev/null | awk -F= '{print $2}' | tr -d '[:space:]' || true)"

  [[ -n "$expected_fp" && -n "$served_fp" && "$expected_fp" == "$served_fp" ]]
}

collect_container_domains() {
  local name="$1"
  local labels="$2"
  local suffix="$3"
  local output_file="$4"

  local compose_service compose_project container_label custom_domains d normalized

  compose_service="$(label_value "${labels:-}" "com.docker.compose.service" || true)"
  compose_project="$(label_value "${labels:-}" "com.docker.compose.project" || true)"
  if [[ -n "$compose_service" && -n "$compose_project" ]]; then
    compose_service="$(normalize_domain_label "$compose_service")"
    compose_project="$(normalize_domain_label "$compose_project")"
    if [[ -n "$compose_service" && -n "$compose_project" ]]; then
      echo "${compose_service}.${compose_project}.${suffix}" >> "$output_file"
    fi
  fi

  container_label="$(normalize_domain_label "$name")"
  if [[ -n "$container_label" ]]; then
    echo "${container_label}.${suffix}" >> "$output_file"
  fi

  custom_domains="$(label_value "${labels:-}" "dev.colimaui.domains" || true)"
  if [[ -n "$custom_domains" ]]; then
    IFS=',' read -r -a custom_parts <<< "$custom_domains"
    for d in "${custom_parts[@]}"; do
      normalized="$(normalize_full_domain "$d" || true)"
      [[ -n "$normalized" ]] && echo "$normalized" >> "$output_file"
    done
  fi
}

sync_routes() {
  local suffix="$1"
  local dynamic_dir="$2"
  mkdir -p "$dynamic_dir"
  docker_reachable || return 0
  ensure_proxy_container "$dynamic_dir" "$CERT_DIR"
  attach_proxy_to_networks

  local routers_file services_file route_keys_file service_keys_file
  routers_file="$(mktemp)"
  services_file="$(mktemp)"
  route_keys_file="$(mktemp)"
  service_keys_file="$(mktemp)"
  local route_idx=0

  add_route() {
    local rule="$1"
    local service="$2"
    local key="${rule}|${service}"
    if grep -Fxq "$key" "$route_keys_file"; then
      return
    fi
    echo "$key" >> "$route_keys_file"
    route_idx=$((route_idx + 1))
    {
      echo "    r${route_idx}:"
      printf '      rule: "%s"\n' "$rule"
      echo '      entryPoints: ["web", "websecure"]'
      echo "      service: ${service}"
      echo '      tls: {}'
    } >> "$routers_file"
  }

  add_service() {
    local service="$1"
    local url="$2"
    if grep -Fxq "$service" "$service_keys_file"; then
      return
    fi
    echo "$service" >> "$service_keys_file"
    {
      echo "    ${service}:"
      echo "      loadBalancer:"
      echo "        servers:"
      echo "          - url: \"${url}\""
    } >> "$services_file"
  }

  add_route "Host(\`index.${suffix}\`)" "api@internal"

  local line id name ports labels port ip short service_name
  while IFS=$'\t' read -r id name ports labels; do
    [[ -z "$id" ]] && continue

    port="$(preferred_http_port "${ports:-}" "${labels:-}")"
    [[ -z "$port" ]] && continue

    ip="$(docker inspect --format '{{range .NetworkSettings.Networks}}{{if .IPAddress}}{{.IPAddress}} {{end}}{{end}}' "$id" 2>/dev/null | awk '{print $1}' || true)"
    [[ -z "$ip" ]] && continue

    short="$(printf '%s' "$id" | tr -cd '[:alnum:]' | cut -c1-12)"
    [[ -z "$short" ]] && short="container"
    service_name="s${short}p${port}"
    add_service "$service_name" "http://${ip}:${port}"

    local domains_file
    domains_file="$(mktemp)"
    local full
    collect_container_domains "$name" "${labels:-}" "$suffix" "$domains_file"

    if [[ -s "$domains_file" ]]; then
      while IFS= read -r full; do
        [[ -z "$full" ]] && continue
        if [[ "$full" == "*."* ]]; then
          add_route "HostRegexp(\`{subdomain:.+}.${full#*.}\`)" "$service_name"
        else
          add_route "Host(\`${full}\`)" "$service_name"
          add_route "HostRegexp(\`{subdomain:.+}.${full}\`)" "$service_name"
        fi
      done < <(sort -u "$domains_file")
    fi

    rm -f "$domains_file"
  done < <(docker ps --format $'{{.ID}}\t{{.Names}}\t{{.Ports}}\t{{.Labels}}')

  {
    echo "http:"
    echo "  routers:"
    if [[ -s "$routers_file" ]]; then
      cat "$routers_file"
    else
      echo "    r1:"
      echo "      rule: \"Host(\`index.${suffix}\`)\""
      echo '      entryPoints: ["web", "websecure"]'
      echo "      service: api@internal"
      echo '      tls: {}'
    fi

    echo "  services:"
    if [[ -s "$services_file" ]]; then
      cat "$services_file"
    else
      echo "    noop:"
      echo "      loadBalancer:"
      echo "        servers:"
      echo "          - url: \"http://127.0.0.1:65535\""
    fi
  } > "${dynamic_dir}/routes.yml"

  rm -f "$routers_file" "$services_file" "$route_keys_file" "$service_keys_file"
}

list_urls() {
  local suffix="dev.local"
  local tmp
  tmp="$(mktemp)"

  echo "https://index.${suffix}" >> "$tmp"

  docker_reachable || die "Docker API unreachable"

  local line id name ports labels port domains_file full
  while IFS=$'\t' read -r id name ports labels; do
    [[ -z "$id" ]] && continue
    [[ "$name" == "colimaui-proxy" ]] && continue

    port="$(preferred_http_port "${ports:-}" "${labels:-}")"
    [[ -z "$port" ]] && continue

    domains_file="$(mktemp)"
    collect_container_domains "$name" "${labels:-}" "$suffix" "$domains_file"

    if [[ -s "$domains_file" ]]; then
      while IFS= read -r full; do
        [[ -z "$full" ]] && continue
        [[ "$full" == "*."* ]] && continue
        echo "https://${full}" >> "$tmp"
      done < <(sort -u "$domains_file")
    fi

    rm -f "$domains_file"
  done < <(docker ps --format $'{{.ID}}\t{{.Names}}\t{{.Ports}}\t{{.Labels}}')

  sort -u "$tmp"
  rm -f "$tmp"
}

list_urls_json() {
  list_urls | /usr/bin/python3 -c 'import json,sys; print(json.dumps([line.rstrip("\n") for line in sys.stdin if line.strip()]))'
}

check_status() {
  local suffix="$1"
  local fail_count=0
  local ok detail
  local brew_pfx managed_conf resolver_file cert_file key_file
  local index_reachable=0
  local local_suffix_reserved="0"

  brew_pfx="$(brew_prefix)"
  managed_conf="${brew_pfx}/etc/dnsmasq.d/${MANAGED_DNSMASQ_CONFIG}"
  resolver_file="/etc/resolver/${suffix}"
  cert_file="${CERT_DIR}/${suffix}.pem"
  key_file="${CERT_DIR}/${suffix}-key.pem"
  [[ "$suffix" == "local" ]] && local_suffix_reserved="1"

  print_check() {
    local title="$1"
    local pass="$2"
    local info="$3"
    if [[ "$pass" == "1" ]]; then
      printf 'PASS  %-22s %s\n' "$title" "$info"
    else
      printf 'FAIL  %-22s %s\n' "$title" "$info"
      fail_count=$((fail_count + 1))
    fi
  }

  if command -v brew >/dev/null 2>&1; then ok=1; detail="Installed"; else ok=0; detail="Missing"; fi
  print_check "Homebrew" "$ok" "$detail"

  if colima status >/dev/null 2>&1; then ok=1; detail="Running"; else ok=0; detail="Not running"; fi
  print_check "Colima runtime" "$ok" "$detail"

  if docker info >/dev/null 2>&1; then ok=1; detail="Reachable"; else ok=0; detail="Unavailable"; fi
  print_check "Docker API" "$ok" "$detail"

  if command -v dnsmasq >/dev/null 2>&1; then ok=1; detail="Installed"; else ok=0; detail="Missing"; fi
  print_check "dnsmasq" "$ok" "$detail"

  if dnsmasq_running; then ok=1; detail="Running on ${DNS_PORT}"; else ok=0; detail="Not running"; fi
  print_check "dnsmasq service" "$ok" "$detail"

  if [[ -f "$managed_conf" ]] && grep -Fqx "address=/.${suffix}/127.0.0.1" "$managed_conf"; then ok=1; detail="*.${suffix} -> 127.0.0.1"; else ok=0; detail="Rule missing"; fi
  print_check "Wildcard DNS" "$ok" "$detail"

  if [[ -f "$resolver_file" ]] && grep -Fqx "nameserver 127.0.0.1" "$resolver_file" && grep -Fqx "port ${DNS_PORT}" "$resolver_file"; then ok=1; detail="$resolver_file configured"; else ok=0; detail="Resolver missing or invalid"; fi
  print_check "macOS resolver" "$ok" "$detail"

  if dnsmasq_running && dscacheutil -q host -a name "colimaui-check.${suffix}" | grep -q 'ip_address: 127.0.0.1'; then
    ok=1
    if [[ "$local_suffix_reserved" == "1" ]]; then
      detail="Hostnames resolve to 127.0.0.1 (.local may still conflict with Bonjour)"
    else
      detail="Hostnames resolve to 127.0.0.1"
    fi
  else
    ok=0
    if [[ "$local_suffix_reserved" == "1" ]]; then
      detail="Wildcard lookup not resolving (.local may be intercepted by Bonjour)"
    else
      detail="Wildcard lookup not resolving"
    fi
  fi
  print_check "Wildcard resolution" "$ok" "$detail"

  if docker ps --format '{{.Names}}' 2>/dev/null | grep -Fxq colimaui-proxy; then
    if proxy_identity_reachable "$suffix" "$cert_file"; then
      ok=1
      detail="colimaui-proxy running and serving expected certificate"
    else
      ok=0
      detail="Proxy reachable but certificate does not match expected local cert"
    fi
  else
    ok=0
    detail="Proxy not running"
  fi
  print_check "Reverse proxy" "$ok" "$detail"

  if command -v mkcert >/dev/null 2>&1; then ok=1; detail="Installed"; else ok=0; detail="Missing"; fi
  print_check "mkcert" "$ok" "$detail"

  if [[ -f "$cert_file" && -f "$key_file" ]]; then ok=1; detail="Wildcard cert generated"; else ok=0; detail="Certificate missing"; fi
  print_check "TLS certificate" "$ok" "$detail"

  if system_curl -ksS --connect-timeout 2 --max-time 4 -o /dev/null "https://index.${suffix}"; then
    index_reachable=1
    ok=1
    if [[ "$local_suffix_reserved" == "1" ]]; then
      detail="HTTPS endpoint reachable (.local may still conflict on some Macs)"
    else
      detail="HTTPS endpoint reachable"
    fi
  else
    ok=0
    if [[ "$local_suffix_reserved" == "1" ]]; then
      detail="Index unreachable or TLS untrusted (.local may be intercepted by Bonjour)"
    else
      detail="Index unreachable or TLS untrusted"
    fi
  fi
  print_check "Domain index" "$ok" "$detail"

  if system_curl -sS --connect-timeout 2 --max-time 4 -o /dev/null "https://index.${suffix}"; then
    ok=1
    detail="Certificate chain trusted"
  else
    ok=0
    if [[ "$index_reachable" == "1" ]]; then
      detail="Reachable but certificate is not trusted"
    else
      detail="Not trusted (or unreachable)"
    fi
  fi
  print_check "TLS trust" "$ok" "$detail"

  if (( fail_count > 0 )); then
    return 1
  fi
  return 0
}

setup_domains() {
  local suffix="$1"
  setup_prepare_domains "$suffix"
  setup_apply_privileged "$suffix"
  setup_finalize_domains "$suffix"
}

setup_prepare_domains() {
  local suffix="$1"

  command -v brew >/dev/null 2>&1 || die "Homebrew is required"

  if [[ "$suffix" == "local" ]]; then
    warn ".local is reserved by macOS Bonjour. For wildcard local domains, use .dev.local, .colima, .mish, or .test."
  fi

  CERT_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/certs"
  DYNAMIC_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/dynamic"

  log "Installing dependencies (dnsmasq, mkcert)..."
  brew list dnsmasq >/dev/null 2>&1 || brew install dnsmasq
  brew list mkcert >/dev/null 2>&1 || brew install mkcert
}

setup_apply_privileged() {
  local suffix="$1"
  local brew_pfx managed_dir managed_conf dnsmasq_conf resolver_file caroot app_support_root
  local owner_user owner_group owner_ref
  local q_managed_dir q_managed_conf q_dnsmasq_conf q_resolver_file q_caroot q_app_support_root q_owner_ref
  local admin_script=""

  brew_pfx="$(brew_prefix)"
  managed_dir="${brew_pfx}/etc/dnsmasq.d"
  managed_conf="${managed_dir}/${MANAGED_DNSMASQ_CONFIG}"
  dnsmasq_conf="${brew_pfx}/etc/dnsmasq.conf"
  resolver_file="/etc/resolver/${suffix}"
  caroot="${MKCERT_CAROOT}"
  app_support_root="$(dirname "$caroot")"

  log "Applying privileged DNS/resolver/trust setup..."
  if (( EUID == 0 )); then
    owner_user="${SUDO_USER:-}"
    if [[ -z "$owner_user" || "$owner_user" == "root" ]]; then
      owner_user="$(stat -f%Su /dev/console 2>/dev/null || true)"
    fi
  else
    owner_user="$(id -un)"
  fi
  if [[ -z "$owner_user" || "$owner_user" == "root" ]]; then
    owner_user="$(printf '%s' "$caroot" | sed -nE 's#^/Users/([^/]+)/.*#\1#p')"
  fi
  if [[ -z "$owner_user" || "$owner_user" == "root" ]]; then
    owner_user="$(id -un)"
  fi
  owner_group="$(id -gn "$owner_user" 2>/dev/null || true)"
  if [[ -n "$owner_group" ]]; then
    owner_ref="${owner_user}:${owner_group}"
  else
    owner_ref="${owner_user}"
  fi
  q_managed_dir="$(shell_quote "$managed_dir")"
  q_managed_conf="$(shell_quote "$managed_conf")"
  q_dnsmasq_conf="$(shell_quote "$dnsmasq_conf")"
  q_resolver_file="$(shell_quote "$resolver_file")"
  q_caroot="$(shell_quote "$caroot")"
  q_app_support_root="$(shell_quote "$app_support_root")"
  q_owner_ref="$(shell_quote "$owner_ref")"

  admin_script="$(cat <<EOF
mkdir -p $q_managed_dir /etc/resolver $q_caroot $q_app_support_root
cat > $q_managed_conf <<'CFG'
# Managed by ColimaUI CLI
listen-address=127.0.0.1
bind-interfaces
port=${DNS_PORT}
address=/.${suffix}/127.0.0.1
CFG
touch $q_dnsmasq_conf
if ! grep -Fqx "conf-file=${managed_conf}" $q_dnsmasq_conf; then
  printf '\n# Managed by ColimaUI CLI\nconf-file=%s\n' "${managed_conf}" >> $q_dnsmasq_conf
fi
cat > $q_resolver_file <<'RES'
nameserver 127.0.0.1
port ${DNS_PORT}
RES
chown -R $q_owner_ref $q_app_support_root >/dev/null 2>&1 || true
EOF
)"
  if (( EUID == 0 )); then
    /bin/zsh -lc "$admin_script" >/dev/null 2>&1 || die "Privileged setup failed."
  else
    run_admin_command "$admin_script" "ColimaUI needs administrator permission to update DNS and resolver settings for .${suffix} domains." || die "Privileged setup was cancelled or failed."
  fi
}

setup_finalize_domains() {
  local suffix="$1"
  local caroot
  local tries=0
  local dnsmasq_service_snapshot=""
  local launchctl_snapshot=""

  caroot="${MKCERT_CAROOT}"

  log "Preparing local CA..."
  ensure_mkcert_ca "$caroot"

  log "Starting dnsmasq service..."
  brew services start dnsmasq >/dev/null 2>&1 || true

  until dnsmasq_running || (( tries >= 120 )); do
    tries=$((tries + 1))
    sleep 0.25
  done
  if ! dnsmasq_running; then
    dnsmasq_service_snapshot="$(brew services list 2>/dev/null | awk 'NR==1 || /^dnsmasq[[:space:]]/')"
    launchctl_snapshot="$({ launchctl print gui/$(id -u)/homebrew.mxcl.dnsmasq 2>/dev/null | awk -F'= ' '/state =|last exit code =/{gsub(/^[ \t]+|[ \t]+$/, \"\", $2); print $1 \": \" $2}'; } || true)"
    die "dnsmasq service failed to start. ${dnsmasq_service_snapshot} ${launchctl_snapshot}"
  fi

  mkdir -p "$CERT_DIR" "$DYNAMIC_DIR"

  install_trust "$suffix"

  log "Generating wildcard certificate for .${suffix}..."
  CAROOT="$caroot" mkcert -cert-file "${CERT_DIR}/${suffix}.pem" -key-file "${CERT_DIR}/${suffix}-key.pem" "*.${suffix}" "${suffix}" "index.${suffix}" localhost 127.0.0.1 ::1 >/dev/null

  write_tls_dynamic "$suffix" "$DYNAMIC_DIR"

  if docker_reachable; then
    log "Refreshing reverse proxy and syncing routes..."
    ensure_proxy_container "$DYNAMIC_DIR" "$CERT_DIR" "1"
    sync_routes "$suffix" "$DYNAMIC_DIR"
    if ! wait_for_proxy_certificate "$suffix" "${CERT_DIR}/${suffix}.pem"; then
      die "Reverse proxy did not serve the expected TLS certificate in time."
    fi
  else
    warn "Docker API unreachable; skipped proxy startup/sync"
  fi

  dscacheutil -flushcache >/dev/null 2>&1 || true
  log ""
  check_status "$suffix"
}

install_trust() {
  local suffix="$1"
  local caroot
  command -v mkcert >/dev/null 2>&1 || die "mkcert is required. Run: colimaui domains setup"
  caroot="${MKCERT_CAROOT}"
  ensure_mkcert_ca "$caroot"

  if ! security add-trusted-cert -d -r trustRoot -k "${HOME}/Library/Keychains/login.keychain-db" "${caroot}/rootCA.pem" >/dev/null 2>&1; then
    die "mkcert trust installation failed for ${caroot}/rootCA.pem"
  fi

  log "TLS trust refreshed for .${suffix}"
}

ensure_mkcert_ca() {
  local caroot="$1"
  local bootstrap_cert bootstrap_key bootstrap_error
  mkdir -p "$caroot"
  if [[ ! -f "${caroot}/rootCA.pem" || ! -f "${caroot}/rootCA-key.pem" ]]; then
    bootstrap_cert="$(mktemp)"
    bootstrap_key="$(mktemp)"
    if ! bootstrap_error="$(CAROOT="$caroot" mkcert -cert-file "$bootstrap_cert" -key-file "$bootstrap_key" localhost 2>&1 >/dev/null)"; then
      rm -f "$bootstrap_cert" "$bootstrap_key"
      die "mkcert CA bootstrap failed: ${bootstrap_error}"
    fi
    rm -f "$bootstrap_cert" "$bootstrap_key"
  fi
  if [[ ! -f "${caroot}/rootCA.pem" ]]; then
    die "mkcert root CA not found at ${caroot}/rootCA.pem"
  fi
}

wait_for_proxy_certificate() {
  local suffix="$1"
  local cert_file="$2"
  local attempts=0

  while (( attempts < 80 )); do
    if proxy_identity_reachable "$suffix" "$cert_file"; then
      return 0
    fi
    attempts=$((attempts + 1))
    sleep 0.25
  done
  return 1
}

unsetup_domains() {
  local suffix="$1"
  local purge_packages="$2"
  local brew_pfx managed_conf dnsmasq_conf resolver_file caroot
  local admin_script=""
  local q_managed_conf q_dnsmasq_conf q_resolver_file

  brew_pfx="$(brew_prefix)"
  managed_conf="${brew_pfx}/etc/dnsmasq.d/${MANAGED_DNSMASQ_CONFIG}"
  dnsmasq_conf="${brew_pfx}/etc/dnsmasq.conf"
  resolver_file="/etc/resolver/${suffix}"
  caroot="${MKCERT_CAROOT}"
  CERT_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/certs"
  DYNAMIC_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/dynamic"

  log "Removing managed proxy and domain config..."
  docker rm -f colimaui-proxy >/dev/null 2>&1 || true
  rm -f "${CERT_DIR}/${suffix}.pem" "${CERT_DIR}/${suffix}-key.pem" "${DYNAMIC_DIR}/routes.yml" "${DYNAMIC_DIR}/tls.yml" >/dev/null 2>&1 || true

  command -v brew >/dev/null 2>&1 && brew services stop dnsmasq >/dev/null 2>&1 || true

  q_managed_conf="$(shell_quote "$managed_conf")"
  q_dnsmasq_conf="$(shell_quote "$dnsmasq_conf")"
  q_resolver_file="$(shell_quote "$resolver_file")"
  admin_script="rm -f $q_managed_conf $q_resolver_file >/dev/null 2>&1 || true
if [[ -f $q_dnsmasq_conf ]]; then
  tmp_file=\$(mktemp)
  grep -Fvx \"conf-file=${managed_conf}\" $q_dnsmasq_conf > \"\$tmp_file\" || true
  cat \"\$tmp_file\" > $q_dnsmasq_conf
  rm -f \"\$tmp_file\"
fi"
  if [[ "$suffix" != "colima" ]]; then
    admin_script="${admin_script}
rm -f /etc/resolver/colima >/dev/null 2>&1 || true"
  fi
  if (( EUID == 0 )); then
    /bin/zsh -lc "$admin_script" >/dev/null 2>&1 || die "Privileged cleanup failed."
  else
    run_admin_command "$admin_script" "ColimaUI needs administrator permission to remove DNS and resolver settings for .${suffix} domains." || die "Privileged cleanup was cancelled or failed."
  fi

  if [[ "$purge_packages" == "1" ]]; then
    log "Purging dnsmasq/mkcert packages..."
    CAROOT="$caroot" mkcert -uninstall >/dev/null 2>&1 || true
    command -v brew >/dev/null 2>&1 && brew uninstall --formula dnsmasq mkcert >/dev/null 2>&1 || true
  fi

  dscacheutil -flushcache >/dev/null 2>&1 || true
  log "Unsetup complete for .${suffix}"
}

sync_domains() {
  local suffix="$1"
  CERT_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/certs"
  DYNAMIC_DIR="${HOME}/Library/Application Support/ColimaUI/proxy/dynamic"
  mkdir -p "$CERT_DIR" "$DYNAMIC_DIR"
  write_tls_dynamic "$suffix" "$DYNAMIC_DIR"
  sync_routes "$suffix" "$DYNAMIC_DIR"
  log "Route sync complete for .${suffix}"
}

main() {
  local namespace="${1:-}"
  local action="${2:-}"
  local suffix=""
  local purge_packages="0"
  local output_json="0"

  if [[ "$namespace" == "-v" || "$namespace" == "--version" ]]; then
    log "${SCRIPT_NAME} ${CLI_VERSION}"
    exit 0
  fi

  if [[ -z "$namespace" || "$namespace" == "-h" || "$namespace" == "--help" ]]; then
    usage
    exit 0
  fi

  if [[ "$namespace" != "domains" ]]; then
    usage
    die "Unknown namespace: $namespace"
  fi

  if [[ -z "$action" || "$action" == "-h" || "$action" == "--help" ]]; then
    usage
    exit 0
  fi

  shift 2
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --suffix)
        suffix="${2:-}"
        shift 2
        ;;
      --purge-packages)
        purge_packages="1"
        shift
        ;;
      --json)
        output_json="1"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        usage
        die "Unknown argument: $1"
        ;;
    esac
  done

  suffix="$(normalize_suffix "${suffix:-}")"
  if [[ -n "$suffix" && "$suffix" != "dev.local" ]]; then
    warn "Ignoring --suffix ${suffix}. ColimaUI domains are fixed to .dev.local."
  fi
  suffix="dev.local"

  if [[ "$output_json" == "1" && "$action" != "urls" ]]; then
    die "--json is only supported with 'colimaui domains urls'"
  fi

  case "$action" in
    setup)
      with_operation_lock setup_domains "$suffix"
      ;;
    trust)
      with_operation_lock install_trust "$suffix"
      ;;
    setup-prep)
      setup_prepare_domains "$suffix"
      ;;
    setup-apply)
      setup_apply_privileged "$suffix"
      ;;
    setup-finalize)
      setup_finalize_domains "$suffix"
      ;;
    check)
      check_status "$suffix"
      ;;
    sync)
      with_operation_lock sync_domains "$suffix"
      ;;
    urls)
      if [[ "$output_json" == "1" ]]; then
        list_urls_json
      else
        list_urls
      fi
      ;;
    unsetup)
      with_operation_lock unsetup_domains "$suffix" "$purge_packages"
      ;;
    *)
      usage
      die "Unknown action: $action"
      ;;
  esac
}

main "$@"
